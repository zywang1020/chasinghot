<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Geoæ˜¯ç‚å€¼å ±éŒ¶</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 30px; }
    label, select, input, button { display: block; margin: 15px 0; }
    #result { margin-top: 30px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background: #f9f9f9; }
  </style>
</head>
<body>
  <h2>ğŸŒ Geoæ˜¯ç‚å€¼å ±éŒ¶ï¼šå³æ™‚é«”æ„Ÿæº«åº¦ä¼°ç®—å™¨</h2>

  <label for="surface">é¸æ“‡é‹ªé¢é¡å‹ï¼š</label>
  <select id="surface">
    <option value="æŸæ²¹">æŸæ²¹</option>
    <option value="æ°´æ³¥">æ°´æ³¥</option>
    <option value="PU">PU</option>
    <option value="è‰åœ°">è‰åœ°</option>
  </select>

  <button onclick="calculateTemp()">è¨ˆç®—æº«åº¦</button>

  <div id="result"></div>

<script>
const apiKey = "CWA-234F005B-7959-436C-A0FF-BD4225C0E339";

const surfaceMap = {
  "æŸæ²¹": { albedo: 0.05 },
  "æ°´æ³¥": { albedo: 0.30 },
  "PU": { albedo: 0.10 },
  "è‰åœ°": { albedo: 0.25 },
};

// å–å¾—ç›®å‰ä½ç½®
function getLocation() {
  return new Promise((resolve, reject) => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => resolve({lat: pos.coords.latitude, lon: pos.coords.longitude}),
        err => reject(err)
      );
    } else {
      reject("Geolocation not supported.");
    }
  });
}

// æ‰¾æœ€è¿‘çš„æ¸¬ç«™ (æ¨¡æ“¬ä¸€å€‹åˆ—è¡¨ï¼Œå¯è‡ªè¡Œæ“´å……)
const stations = [
  { name: "è‡ºåŒ—", lat: 25.0375, lon: 121.5637, id: "466920" },
  { name: "æ¿æ©‹", lat: 25.0143, lon: 121.4672, id: "466910" },
  { name: "æ–°ç«¹", lat: 24.8138, lon: 120.9675, id: "467571" },
  { name: "å˜‰ç¾©", lat: 23.4950, lon: 120.4329, id: "467480" },
  { name: "è‡ºå—", lat: 22.9975, lon: 120.2121, id: "467410" },
  { name: "é«˜é›„", lat: 22.6273, lon: 120.3014, id: "467440" },
  { name: "èŠ±è“®", lat: 23.9722, lon: 121.6060, id: "466990" },
  { name: "è‡ºæ±", lat: 22.7519, lon: 121.1500, id: "467660" }
];

// è¨ˆç®—å…©åœ°è·é›¢
function calcDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // åœ°çƒåŠå¾‘
  const dLat = (lat2 - lat1) * Math.PI/180;
  const dLon = (lon2 - lon1) * Math.PI/180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// æ‰¾æœ€è¿‘æ¸¬ç«™
function findNearestStation(userLat, userLon) {
  let minDist = Infinity;
  let nearest = null;
  stations.forEach(station => {
    const d = calcDistance(userLat, userLon, station.lat, station.lon);
    if (d < minDist) {
      minDist = d;
      nearest = station;
    }
  });
  return nearest;
}

// å–å¾—æ°£è±¡è³‡æ–™
async function getWeather(stationId) {
  const tempUrl = `https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0001-001?Authorization=${apiKey}&stationId=${stationId}`;
  const radiationUrl = `https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0003-001?Authorization=${apiKey}&stationId=${stationId}`;
  
  const [tempRes, radRes] = await Promise.all([
    fetch(tempUrl), fetch(radiationUrl)
  ]);
  const tempJson = await tempRes.json();
  const radJson = await radRes.json();

  const T = parseFloat(tempJson.records.location[0].weatherElement.find(e => e.elementName=="TEMP").elementValue);
  const radiationData = radJson.records.location[0].weatherElement.find(e => e.elementName=="H_wa");
  const C = parseFloat(radiationData ? radiationData.elementValue : 0);

  return { T, C };
}

async function calculateTemp() {
  try {
    const {lat, lon} = await getLocation();
    const nearestStation = findNearestStation(lat, lon);

    const surfaceType = document.getElementById("surface").value;
    const { T, C } = await getWeather(nearestStation.id);

    const B = 0.3 * C;
    const A = T - 20;  // ç²—ç•¥ä¼°è¨ˆåœ°é¢ç™½å¤©èˆ‡å¤œæ™šæº«å·®ï¼Œå¯¦éš›å¯æ ¹æ“šAPIæ‹¿æ›´ç²¾ç¢ºæ•¸å€¼
    const cloudFactor = A / B;
    const actualRadiation = cloudFactor * C;
    const albedo = surfaceMap[surfaceType].albedo;

    const surfaceTemp = actualRadiation * (1 - albedo);
    const feelTemp = surfaceTemp + 5;

    document.getElementById("result").innerHTML = `
      <b>å®šä½ï¼š</b>${nearestStation.name}<br>
      <b>æ°£æº«ï¼š</b>${T}Â°C<br>
      <b>ç†è«–å¤ªé™½è¼»å°„Cï¼š</b>${C.toFixed(1)} W/mÂ²<br>
      <b>æ¨ç®—é›²é‡æ¯”ï¼š</b>${cloudFactor.toFixed(2)}<br>
      <b>å¯¦éš›å¤ªé™½è¼»å°„ï¼š</b>${actualRadiation.toFixed(1)} W/mÂ²<br>
      <b>${surfaceType} è¡¨é¢æº«åº¦ï¼š</b>${surfaceTemp.toFixed(1)}Â°C<br>
      <b>é«”æ„Ÿæº«åº¦ï¼š</b>${feelTemp.toFixed(1)}Â°C
    `;
  } catch (err) {
    console.error(err);
    document.getElementById("result").innerHTML = "âš¡ ç„¡æ³•å®šä½æˆ–å–å¾—è³‡æ–™ï¼Œè«‹å…è¨±å®šä½æˆ–ç¨å¾Œå†è©¦";
  }
}
</script>

</body>
</html>
