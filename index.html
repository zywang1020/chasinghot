<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Geoæ˜¯ç‚å€¼çˆ†éŒ¶</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 30px auto;
      padding: 20px;
      background: #f9f9f9;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h2 {
      text-align: center;
    }
    label, select, input, button {
      width: 100%;
      margin-top: 15px;
      padding: 10px;
      font-size: 16px;
    }
    #result {
      margin-top: 30px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>

<h2>ğŸŒ Geoæ˜¯ç‚å€¼çˆ†éŒ¶ï¼šå³æ™‚é«”æ„Ÿæº«åº¦ä¼°ç®—å™¨</h2>

<label for="date">é¸æ“‡æ—¥æœŸï¼š</label>
<input type="date" id="date" required>

<label for="surface">é¸æ“‡é‹ªé¢é¡å‹ï¼š</label>
<select id="surface">
  <option value="æŸæ²¹">æŸæ²¹</option>
  <option value="æ°´æ³¥">æ°´æ³¥</option>
  <option value="PU">PU</option>
  <option value="è‰åœ°">è‰åœ°</option>
</select>

<button onclick="startCalculation()">é–‹å§‹è¨ˆç®—</button>

<div id="result"></div>

<script>
const apiKey = "CWA-234F005B-7959-436C-A0FF-BD4225C0E339";

// æ¸¬ç«™è³‡æ–™ (åç¨±+ç¶“ç·¯åº¦)ï¼Œå¯ä»¥å†æ“´å……
const stations = [
  { name: "è‡ºåŒ—", lat: 25.0375, lon: 121.5637 },
  { name: "æ¿æ©‹", lat: 25.0143, lon: 121.4637 },
  { name: "æ–°ç«¹", lat: 24.8066, lon: 120.9686 },
  { name: "å˜‰ç¾©", lat: 23.4801, lon: 120.4491 },
  { name: "è‡ºå—", lat: 22.9997, lon: 120.2270 },
  { name: "é«˜é›„", lat: 22.6273, lon: 120.3014 },
  { name: "èŠ±è“®", lat: 23.9722, lon: 121.6044 },
  { name: "è‡ºæ±", lat: 22.7583, lon: 121.1444 },
];

// å„é‹ªé¢åç…§ç‡
const surfaceMap = {
  "æŸæ²¹": { albedo: 0.05 },
  "æ°´æ³¥": { albedo: 0.30 },
  "PU": { albedo: 0.10 },
  "è‰åœ°": { albedo: 0.25 },
};

// è¨ˆç®—å…©é»é–“è·é›¢
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // åœ°çƒåŠå¾‘(å…¬é‡Œ)
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// æ‰¾æœ€è¿‘æ¸¬ç«™
function findNearestStation(userLat, userLon) {
  let minDistance = Infinity;
  let nearestStation = null;
  stations.forEach(station => {
    const distance = getDistance(userLat, userLon, station.lat, station.lon);
    if (distance < minDistance) {
      minDistance = distance;
      nearestStation = station;
    }
  });
  return nearestStation;
}

// å–å¾—æ°£è±¡è³‡æ–™
async function getWeatherData(stationName) {
  try {
    const radiationUrl = `https://opendata.cwa.gov.tw/api/v1/rest/datastore/C-B0025-001?Authorization=${apiKey}&format=JSON&locationName=${stationName}`;
    const tempUrl = `https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0003-001?Authorization=${apiKey}&format=JSON&locationName=${stationName}`;

    const [radiationRes, tempRes] = await Promise.all([
      fetch(radiationUrl),
      fetch(tempUrl)
    ]);

    const radiationData = await radiationRes.json();
    const tempData = await tempRes.json();

    const C = parseFloat(radiationData.records.location[0].weatherElement[0].elementValue);
    const temps = tempData.records.location[0].weatherElement;
    const maxTemp = parseFloat(temps.find(el => el.elementName === "MaxT").elementValue);
    const minTemp = parseFloat(temps.find(el => el.elementName === "MinT").elementValue);
    const A = maxTemp - minTemp;

    return { C, A };
  } catch (error) {
    console.error("å–å¾—æ°£è±¡è³‡æ–™å¤±æ•—ï¼š", error);
    return null;
  }
}

// ç†±ç­‰ç´šåˆ¤æ–·
function getHeatLevel(temp) {
  if (temp >= 50) return "æ¥µé«˜ ğŸŒ¡ï¸";
  if (temp >= 40) return "é«˜ â˜€ï¸";
  if (temp >= 35) return "ä¸­ç­‰ ğŸŒ¤ï¸";
  return "ä½ ğŸŒ¿";
}

// ä¸»ç¨‹å¼
function startCalculation() {
  if (!navigator.geolocation) {
    alert("ç„¡æ³•å–å¾—å®šä½è³‡è¨Šï¼");
    return;
  }

  navigator.geolocation.getCurrentPosition(async function(position) {
    const userLat = position.coords.latitude;
    const userLon = position.coords.longitude;

    const nearestStation = findNearestStation(userLat, userLon);
    if (!nearestStation) {
      document.getElementById("result").innerHTML = "âŒ æ‰¾ä¸åˆ°é™„è¿‘æ¸¬ç«™ï¼";
      return;
    }

    const surfaceType = document.getElementById("surface").value;
    const weatherData = await getWeatherData(nearestStation.name);
    if (!weatherData) {
      document.getElementById("result").innerHTML = "âŒ ç„¡æ³•å–å¾—æ°£è±¡è³‡æ–™ï¼";
      return;
    }

    const { C, A } = weatherData;
    const B = 0.3 * C;
    const cloudFactor = A / B;
    const actualRadiation = cloudFactor * C;

    const albedo = surfaceMap[surfaceType].albedo;
    const surfaceTemp = actualRadiation * (1 - albedo);
    const feelTemp = surfaceTemp + 5;
    const heatLevel = getHeatLevel(surfaceTemp);

    document.getElementById("result").innerHTML = `
      <strong>è‡ªå‹•å®šä½åˆ°æœ€è¿‘æ¸¬ç«™ï¼š</strong> ${nearestStation.name}<br>
      <strong>å¤ªé™½è¼»å°„é‡ï¼ˆC å€¼ï¼‰ï¼š</strong> ${C.toFixed(1)} W/mÂ²<br>
      <strong>å¯¦éš›æº«å·®ï¼ˆA å€¼ï¼‰ï¼š</strong> ${A.toFixed(1)}Â°C<br>
      <strong>ç†è«–æº«å·®ï¼ˆB å€¼ï¼‰ï¼š</strong> ${B.toFixed(1)}Â°C<br>
      <strong>é›²é‡ä¿‚æ•¸ï¼ˆA/Bï¼‰ï¼š</strong> ${cloudFactor.toFixed(2)}<br>
      <strong>ä¿®æ­£å¾Œå¤ªé™½è¼»å°„é‡ï¼š</strong> ${actualRadiation.toFixed(1)} W/mÂ²<br>
      <strong>${surfaceType} è¡¨é¢æº«åº¦ï¼š</strong> ${surfaceTemp.toFixed(1)}Â°C<br>
      <strong>é«”æ„Ÿæº«åº¦ï¼š</strong> ${feelTemp.toFixed(1)}Â°C<br>
      <strong>ç†±è² è·ç­‰ç´šï¼š</strong> ${heatLevel}
    `;
  }, function(error) {
    console.error(error);
    document.getElementById("result").innerHTML = "âŒ å®šä½å¤±æ•—ï¼Œè«‹ç¢ºèªå…è¨±ç¶²ç«™å–å¾—ä½ç½®ã€‚";
  });
}
</script>

</body>
</html>
